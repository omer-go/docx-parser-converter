/**
 * @file text_converter.test.js
 * @description Integration tests for convertDocxToText.
 */

import { convertDocxToText } from '../index.js';
import { sampleDocxBase64 } from './sample_docx_content.js';

// Helper function to convert Base64 to ArrayBuffer (Node.js specific)
function base64ToArrayBuffer(base64) {
  const buffer = Buffer.from(base64, 'base64');
  // Create an ArrayBuffer from the Buffer:
  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
}

describe('convertDocxToText Integration Tests', () => {
  let docxBuffer;

  beforeAll(() => {
    // Decode the Base64 sample DOCX content once for all tests in this suite
    docxBuffer = base64ToArrayBuffer(sampleDocxBase64);
  });

  test('should convert sample DOCX to plain text', async () => {
    const text = await convertDocxToText(docxBuffer);

    // Basic assertions
    expect(text).toBeDefined();
    expect(typeof text).toBe('string');
    expect(text.length).toBeGreaterThan(0);

    // Check for specific text content from the sample DOCX
    expect(text).toContain('This is a simple paragraph.');
    expect(text).toContain('This is bold and this is italic.'); // Formatting should be gone
    expect(text).toContain('Item 1');
    expect(text).toContain('Item 2');
    expect(text).toContain('This paragraph is centered.');

    // Check for list markers (default for unordered is '• ')
    // The _convertListToText adds a space after the marker.
    expect(text).toMatch(/• Item 1/);
    expect(text).toMatch(/• Item 2/);
    
    // Check for paragraph breaks (default is "\n\n")
    // The exact number of breaks can be tricky due to list processing.
    // We expect at least one double newline sequence.
    expect(text).toContain('\n\n');

    // Centered paragraph might have leading spaces if lineWidth option was used.
    // The sample docx has "This paragraph is centered."
    // With default TextConverter options (no lineWidth), it should not have excessive leading spaces.
    // If a lineWidth was set small, it might wrap or be padded.
    // For now, just check the content.
    const centeredText = "This paragraph is centered.";
    const lines = text.split('\n');
    const centeredLine = lines.find(line => line.includes(centeredText));
    expect(centeredLine).toBeDefined();
    // If lineWidth was used, this might be: expect(centeredLine.trim()).toBe(centeredText);
    // For default, it should be fairly clean:
    expect(centeredLine.trim()).toBe(centeredText);


    // Snapshot testing for more comprehensive checks (optional, enable if desired)
    // expect(text).toMatchSnapshot();
  });

  test('should apply textOptions correctly', async () => {
    const options = {
      lineWidth: 80, // Example, though current centering is very basic
      listItemIndent: "  -> ",
      paragraphBreak: "\r\n---\r\n",
      listItemBreak: "\r\n",
    };
    const text = await convertDocxToText(docxBuffer, options);

    expect(text).toContain('This is a simple paragraph.');
    expect(text).toContain('This is bold and this is italic.');
    
    // Check for custom list item indentation and marker (marker is part of paragraph content here)
    // The list item text is generated by _convertParagraphToText(paragraph, { marker, indent })
    // The marker is from _generateListMarkerText, indent from options.listItemIndent.repeat(level)
    expect(text).toMatch(/ {2}-> • Item 1/); // Default '• ' marker, custom indent "  -> " (0 level indent for first level)
    expect(text).toMatch(/ {2}-> • Item 2/);


    // Check for custom paragraph breaks
    expect(text).toContain("\r\n---\r\n");
    
    // Check for custom list item breaks (between items in the same list)
    // This will be between "  -> • Item 1" and "  -> • Item 2"
    const listPart = text.substring(text.indexOf("-> • Item 1"), text.indexOf("-> • Item 2") + "-> • Item 2".length);
    expect(listPart).toContain("\r\n  -> • Item 2"); // listItemBreak is \r\n, then indent for next item
  });

  test('should return empty string for null input buffer', async () => {
     try {
        await convertDocxToText(null);
     } catch (e) {
        expect(e.message).toBe('docxBuffer is required.');
     }
  });
});
